spring:
  application:
    name: budgetbuddy-backend
  
  # Redis Configuration
  # CRITICAL: Redis is optional - application will automatically fall back to backend (DynamoDB) when Redis is unavailable
  data:
    # Configure Spring Data to handle multiple repository types
    # We use DynamoDB repositories (custom @Repository) and Redis (for caching/locking only)
    # Disable automatic repository detection for Redis since we don't use Redis repositories
    redis:
      repositories:
        enabled: false  # Disable Redis repositories - we only use Redis for caching/locking
      host: ${SPRING_DATA_REDIS_HOST:localhost}
      port: ${SPRING_DATA_REDIS_PORT:6379}
      timeout: 1000ms  # Reduced from 2000ms for faster failure detection
      connect-timeout: 1000ms  # Reduced from 2000ms for faster connection establishment
      # Make Redis optional - don't fail startup if Redis is unavailable
      # Application will automatically fall back to backend (DynamoDB) operations
      lettuce:
        pool:
          # Redis connection pool configuration - now fully configurable
          max-active: ${SPRING_DATA_REDIS_POOL_MAX_ACTIVE:32}  # Increased to handle concurrent health checks and Maven tests
          max-idle: ${SPRING_DATA_REDIS_POOL_MAX_IDLE:16}
          min-idle: ${SPRING_DATA_REDIS_POOL_MIN_IDLE:4}  # Pre-warm pool with 4 connections (avoids cold start delays)
          max-wait: ${SPRING_DATA_REDIS_POOL_MAX_WAIT:500ms}  # Reduced to 500ms - fail fast if pool exhausted
          # Connection validation and reuse - critical for handling Redis restarts
          test-on-borrow: ${SPRING_DATA_REDIS_POOL_TEST_ON_BORROW:true}  # Test connections before using (detect stale connections)
          test-while-idle: ${SPRING_DATA_REDIS_POOL_TEST_WHILE_IDLE:true}  # Test idle connections periodically
          test-on-return: ${SPRING_DATA_REDIS_POOL_TEST_ON_RETURN:true}  # Test connections when returning to pool (catch stale connections)
          time-between-eviction-runs: ${SPRING_DATA_REDIS_POOL_TIME_BETWEEN_EVICTION:10s}  # Check idle connections every 10s (faster detection of stale connections)
          min-evictable-idle-time: ${SPRING_DATA_REDIS_POOL_MIN_EVICTABLE_IDLE:30s}  # Evict connections idle for 30s (removes stale connections faster)
          num-tests-per-eviction-run: ${SPRING_DATA_REDIS_POOL_NUM_TESTS_PER_EVICTION:3}  # Test 3 connections per eviction run (faster cleanup)
        shutdown-timeout: ${SPRING_DATA_REDIS_SHUTDOWN_TIMEOUT:100ms}  # Fast shutdown for health checks
  
  # Jackson Configuration
  jackson:
    serialization:
      write-dates-as-timestamps: false
    time-zone: UTC

# Server Configuration
server:
  port: ${SERVER_PORT:8080}  # Fixed port - do not change
  address: ${SERVER_ADDRESS:0.0.0.0}  # Bind to all interfaces (0.0.0.0) to allow network access, use 127.0.0.1 for localhost only
  # SSL/HTTPS Configuration (optional for local development)
  ssl:
    enabled: ${SERVER_SSL_ENABLED:false}
    key-store: ${SERVER_SSL_KEY_STORE:classpath:keystore.p12}
    key-store-password: ${SERVER_SSL_KEY_STORE_PASSWORD:changeit}
    key-store-type: ${SERVER_SSL_KEY_STORE_TYPE:PKCS12}
    key-alias: ${SERVER_SSL_KEY_ALIAS:budgetbuddy}
    protocol: TLS
    enabled-protocols: ${SERVER_SSL_ENABLED_PROTOCOLS:TLSv1.2,TLSv1.3}
    ciphers: ${SERVER_SSL_CIPHERS:TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}
  error:
    include-message: always
    include-binding-errors: always
    include-stacktrace: on_param
    include-exception: false
  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/xml,text/plain

# Application Configuration
app:
  # DNS Cache Configuration
  # Resilience strategy: Keep cached addresses during DNS outages, don't cache errors
  dns:
    cache:
      # Long positive TTL: Keep successful DNS lookups cached for extended periods
      # If DNS server becomes unavailable, continue using cached addresses
      # Default: 3600 seconds (1 hour) - allows operation during DNS outages
      ttl-seconds: 3600
      # Very short negative TTL: Don't cache DNS lookup failures
      # Failed lookups expire quickly, allowing retry when DNS/server recovers
      # Default: 1 second - minimal caching of errors for quick recovery
      negative-ttl-seconds: 1
  name: BudgetBuddy Backend
  version: 1.0.0
  
  # AWS Configuration
  aws:
    region: ${AWS_REGION:us-east-1}
    dynamodb:
      table-prefix: ${DYNAMODB_TABLE_PREFIX:BudgetBuddy}
      endpoint: ${DYNAMODB_ENDPOINT:} # Leave empty for production, use for LocalStack
    s3:
      bucket-name: ${AWS_S3_BUCKET:budgetbuddy-storage}
    cloudwatch:
      enabled: ${AWS_CLOUDWATCH_ENABLED:true}
      namespace: BudgetBuddy
      log-group: ${AWS_CLOUDWATCH_LOG_GROUP:/aws/ecs/budgetbuddy-backend}
    iam:
      role-arn: ${AWS_IAM_ROLE_ARN:} # ECS Task Role ARN
    kms:
      key-id: ${AWS_KMS_KEY_ID:} # For encryption at rest
    appconfig:
      enabled: ${APP_CONFIG_ENABLED:true} # Enabled by default to match production
      application: ${APP_CONFIG_APPLICATION:budgetbuddy-backend}
      environment: ${APP_CONFIG_ENVIRONMENT:production}
      config-profile: ${APP_CONFIG_PROFILE:default}
      refresh-interval: ${APP_CONFIG_REFRESH_INTERVAL:60}
    secrets-manager:
      enabled: ${AWS_SECRETS_MANAGER_ENABLED:true} # Enabled by default to match production
      refresh-interval: ${AWS_SECRETS_MANAGER_REFRESH_INTERVAL:3600}
  
  # JWT Configuration - Zero Trust: Short-lived access tokens, longer refresh tokens
  jwt:
    secret: ${JWT_SECRET:your-256-bit-secret-key-change-in-production}
    secret-name: ${JWT_SECRET_NAME:budgetbuddy/jwt-secret}
    expiration: 1800000 # 30 minutes (short-lived for Zero Trust, balanced for user workflow)
    refresh-expiration: 2592000000 # 30 days (longer-lived, encrypted in keychain)
  
  # Plaid Configuration
  plaid:
    client-id: ${PLAID_CLIENT_ID:}
    secret: ${PLAID_SECRET:}
    environment: ${PLAID_ENVIRONMENT:sandbox} # sandbox, development, production
    webhook-verification-key: ${PLAID_WEBHOOK_VERIFICATION_KEY:}
    redirect-uri: ${PLAID_REDIRECT_URI:https://app.budgetbuddy.com/plaid/callback} # OAuth redirect URI
    webhook-url: ${PLAID_WEBHOOK_URL:https://api.budgetbuddy.com/api/plaid/webhooks} # Webhook endpoint
  
  # Apple Configuration (for Universal Links)
  apple:
    team-id: ${APPLE_TEAM_ID:TEAM_ID} # Replace with your Apple Developer Team ID
    bundle-id: ${APPLE_BUNDLE_ID:com.budgetbuddy.app}
  
  # Stripe Configuration
  stripe:
    secret-key: ${STRIPE_SECRET_KEY:sk_test_placeholder}
  
  # Pagination Configuration
  pagination:
    default-page-size: ${APP_PAGINATION_DEFAULT_SIZE:50}
    max-page-size: ${APP_PAGINATION_MAX_SIZE:1000}
  
  # Rate Limiting
  rate-limit:
    enabled: true
    requests-per-minute: 20000 # Increased for heavy business users
    requests-per-hour: 1000000 # Increased for heavy business users (1M per hour)
    # Per-endpoint rate limits (per user, per 60 seconds)
    # Increased for heavy business users with large transaction volumes
    auth-login: 2000 # Increased for business users with multiple devices
    auth-signup: 1000 # Increased for business onboarding
    plaid: 100000 # Very high - Plaid errors are common and need retries
    transactions: 1000000 # Very high - heavy users sync thousands of transactions
    analytics: 200000 # Increased for business analytics
    default: 1000000 # High default for business operations
    # DDoS protection (IP-based) - increased for legitimate heavy usage
    ddos:
      max-requests-per-minute: 200000 # Increased for heavy business users
      max-requests-per-hour: 10000000 # 10M per hour - supports heavy business operations
      # DDoS protection configuration - now fully configurable
      block-duration-seconds: ${APP_DDOS_BLOCK_DURATION:3600} # 1 hour block
      max-cache-size: ${APP_DDOS_MAX_CACHE_SIZE:10000} # Prevent unbounded growth
      cache-cleanup-interval-ms: ${APP_DDOS_CACHE_CLEANUP_INTERVAL:300000} # 5 minutes
      cache-ttl-ms: ${APP_DDOS_CACHE_TTL:60000} # 1 minute
      dynamodb-check-interval-ms: ${APP_DDOS_DYNAMODB_CHECK_INTERVAL:60000} # Check every minute
      # 404 Error Tracking - Plaid errors are common, don't block legitimate retries
      notfound:
        max-per-minute: 1000 # Allow many 404s (Plaid errors are common)
        max-per-hour: 10000 # Allow retries for Plaid connection issues
  
  # Security
  security:
    cors:
      # In development, leave empty or set to "*" to allow all origins
      # In production, set specific allowed origins
      allowed-origins: ${CORS_ALLOWED_ORIGINS:}
      allowed-methods: GET,POST,PUT,DELETE,OPTIONS
      allowed-headers: "*"
      allow-credentials: true
    encryption:
      algorithm: AES-256-GCM
      key: ${ENCRYPTION_KEY:change-in-production}
    tls:
      min-version: ${TLS_MIN_VERSION:TLSv1.2}
      enabled-protocols: ${TLS_ENABLED_PROTOCOLS:TLSv1.2,TLSv1.3}
    certificate-pinning:
      enabled: ${CERTIFICATE_PINNING_ENABLED:true}
      certificates: ${CERTIFICATE_PINNED_HASHES:} # Comma-separated list of SHA-256 hashes
  
  # MFA Configuration
  mfa:
    totp:
      issuer: ${MFA_TOTP_ISSUER:BudgetBuddy}
    backup-codes:
      count: ${MFA_BACKUP_CODES_COUNT:10}
      length: ${MFA_BACKUP_CODES_LENGTH:8}
    otp:
      expiration-seconds: ${MFA_OTP_EXPIRATION_SECONDS:300}
    # Return OTP in response (only for dev/test environments)
    # Set to true for LocalStack/CI/testing, false for staging/production
    return-otp-in-response: ${MFA_RETURN_OTP_IN_RESPONSE:false}

  # FIDO2/WebAuthn Configuration
  fido2:
    rp-id: ${FIDO2_RP_ID:budgetbuddy.com}
    rp-name: ${FIDO2_RP_NAME:BudgetBuddy}
    origin: ${FIDO2_ORIGIN:https://budgetbuddy.com}
    challenge:
      expiration-seconds: ${FIDO2_CHALLENGE_EXPIRATION_SECONDS:300}

  # Device Attestation Configuration
  device-attestation:
    enabled: ${DEVICE_ATTESTATION_ENABLED:true}
    devicecheck-enabled: ${DEVICE_ATTESTATION_DEVICECHECK_ENABLED:true}
    play-integrity-enabled: ${DEVICE_ATTESTATION_PLAY_INTEGRITY_ENABLED:true}
    trust-window-hours: ${DEVICE_ATTESTATION_TRUST_WINDOW_HOURS:24}

  # Behavioral Analysis Configuration
  behavioral-analysis:
    enabled: ${BEHAVIORAL_ANALYSIS_ENABLED:true}
    activity-history-size: ${BEHAVIORAL_ANALYSIS_HISTORY_SIZE:100}
    anomaly-detection-window-seconds: ${BEHAVIORAL_ANALYSIS_WINDOW_SECONDS:3600}
    high-risk-threshold: ${BEHAVIORAL_ANALYSIS_HIGH_RISK_THRESHOLD:70.0}
    medium-risk-threshold: ${BEHAVIORAL_ANALYSIS_MEDIUM_RISK_THRESHOLD:40.0}

  # Compliance
  compliance:
    audit-log:
      enabled: true
      retention-days: 2555 # 7 years
    data-retention:
      enabled: true
      user-data-retention-days: 1095 # 3 years
      transaction-data-retention-days: 2555 # 7 years
  
  # Analytics
  analytics:
    enabled: true
    batch-size: 1000
    aggregation-interval: 3600 # 1 hour
  
  # Feature Flags
  features:
    enable-plaid: ${FEATURE_PLAID_ENABLED:true}
    enable-stripe: ${FEATURE_STRIPE_ENABLED:true}
    enable-oauth2: ${FEATURE_OAUTH2_ENABLED:false}
    enable-advanced-analytics: ${FEATURE_ADVANCED_ANALYTICS_ENABLED:false}
    enable-notifications: ${FEATURE_NOTIFICATIONS_ENABLED:true}
  
  # Email Notification Configuration
  notifications:
    enabled: ${APP_NOTIFICATIONS_ENABLED:true}
    email:
      from: ${APP_NOTIFICATIONS_EMAIL_FROM:noreply@budgetbuddy.com}
      # AWS SES Configuration
      # The SES client is configured in NotificationConfig.java
      # For production, ensure:
      # 1. AWS SES is configured in the target region
      # 2. The sender email is verified in SES
      # 3. IAM role has SES permissions (SendEmail, SendTemplatedEmail)
    sns:
      topic-arn: ${APP_NOTIFICATIONS_SNS_TOPIC_ARN:}
      # SNS topic ARN for multi-channel notifications (optional)

# Actuator Configuration (Minimal - only essential endpoints)
management:
  endpoints:
    web:
      exposure:
        include: health,info
      base-path: /actuator
  endpoint:
    health:
      show-details: when-authorized
      probes:
        enabled: true
  health:
    # Configure timeouts for health contributors to prevent slow health checks
    # Redis is optional for caching/locking - failures should not affect overall health
    redis:
      enabled: true
      timeout: 1s  # Reduced to 1 second for faster failure detection
    # Health groups - Redis failures should not affect liveness/readiness
    # Redis is optional for caching/locking - app can function without it
    group:
      liveness:
        include: liveness
      readiness:
        include: readiness
        exclude: redis  # Exclude Redis from readiness check (optional dependency)
    # Circuit breaker for health checks - prevent cascading failures
    circuitbreakers:
      enabled: false  # Disable circuit breakers for health checks (they can cause false negatives)
  metrics:
    export:
      cloudwatch:
        enabled: ${AWS_CLOUDWATCH_ENABLED:true}
        namespace: ${spring.application.name}
    tags:
      application: ${spring.application.name}
  tracing:
    enabled: ${MANAGEMENT_TRACING_ENABLED:false}
    sampling:
      probability: ${MANAGEMENT_TRACING_SAMPLING_PROBABILITY:1.0}

# Logging Configuration (Structured Logging with Correlation IDs)
logging:
  level:
    root: INFO
    com.budgetbuddy: INFO
    org.springframework.security: WARN
    org.springframework.security.config.annotation.authentication.configuration.InitializeUserDetailsBeanManagerConfigurer: ERROR
    software.amazon.awssdk: WARN
    org.springframework.web: WARN
    org.hibernate: WARN
    zipkin: WARN
    brave: WARN
    io.lettuce.core: WARN
    # Suppress ConnectionWatchdog warnings during Redis restarts and DNS resolution failures
    # These are expected when Redis restarts or DNS is temporarily unavailable - Lettuce will automatically reconnect
    # once Redis/DNS is available again. The warning is informational, not an error.
    io.lettuce.core.protocol.ConnectionWatchdog: DEBUG  # Suppress WARN/INFO - only show at DEBUG level
    # Suppress DNS resolution errors during Redis reconnection attempts
    # These are transient and will resolve once DNS/server is available
    java.net: INFO  # Reduce UnknownHostException noise during Redis reconnection
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] [%X{correlationId}] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] [%X{correlationId}] %-5level %logger{36} - %msg%n"
  # CloudWatch Logs integration via ECS log driver
  # Retention: 7 days (configured in CloudFormation)

# Metrics Configuration
metrics:
  enabled: ${METRICS_ENABLED:true}
  filter-unnecessary: ${METRICS_FILTER:true}
  export:
    cloudwatch:
      enabled: ${AWS_CLOUDWATCH_ENABLED:true}
      namespace: ${spring.application.name}
      batch-size: 20  # Batch metrics to reduce costs

# OAuth2 Configuration
oauth2:
  enabled: ${OAUTH2_ENABLED:false}
  jwt:
    issuer-uri: ${OAUTH2_ISSUER_URI:}
    jwk-set-uri: ${OAUTH2_JWK_SET_URI:}

# API Configuration
api:
  version: 1.0.0
  base-url: ${API_BASE_URL:https://api.budgetbuddy.com}
  default-locale: ${API_DEFAULT_LOCALE:en_US}
  supported-locales: ${API_SUPPORTED_LOCALES:en_US,en_GB,fr_FR,es_ES,de_DE,it_IT,ja_JP,zh_CN,ko_KR,pt_BR,ru_RU,ar_SA,hi_IN}

# Feature Flags (merged into app section above)

  # Performance Configuration
  performance:
    async:
      core-pool-size: ${ASYNC_CORE_POOL_SIZE:10}
      max-pool-size: ${ASYNC_MAX_POOL_SIZE:50}
      queue-capacity: ${ASYNC_QUEUE_CAPACITY:100}
    cache:
      default-ttl: ${CACHE_DEFAULT_TTL:1800}
      max-size: ${CACHE_MAX_SIZE:10000}
      warming:
        enabled: ${CACHE_WARMING_ENABLED:true} # Enabled by default to match production

# Resilience Configuration
resilience:
  circuit-breaker:
    failure-rate-threshold: ${CIRCUIT_BREAKER_FAILURE_RATE:50}
    wait-duration: ${CIRCUIT_BREAKER_WAIT_DURATION:60}
    sliding-window-size: ${CIRCUIT_BREAKER_WINDOW_SIZE:10}
  retry:
    max-attempts: ${RETRY_MAX_ATTEMPTS:3}
    wait-duration: ${RETRY_WAIT_DURATION:1000}

# AWS AppConfig Configuration (merged into app.aws section above)

# Deployment Safety Configuration
deployment:
  health-check-timeout: ${DEPLOYMENT_HEALTH_CHECK_TIMEOUT:60}
  health-check-interval: ${DEPLOYMENT_HEALTH_CHECK_INTERVAL:5}
  max-health-check-attempts: ${DEPLOYMENT_MAX_HEALTH_CHECK_ATTEMPTS:12}
  smoke-test-endpoints: ${DEPLOYMENT_SMOKE_TEST_ENDPOINTS:/actuator/health,/api/auth/register}

# OpenAPI/Swagger Configuration
springdoc:
  api-docs:
    path: /api-docs
  swagger-ui:
    path: /swagger-ui.html
    enabled: true
    tags-sorter: alpha
    operations-sorter: alpha

# Resilience4j Configuration
resilience4j:
  circuitbreaker:
    instances:
      plaid:
        registerHealthIndicator: true
        # More lenient settings for Plaid (external service with potential transient failures)
        # Sliding window: Look at last 30 calls (more buffer for genuine failures)
        slidingWindowSize: 30
        # Minimum calls: Need at least 15 calls before circuit can open (prevents premature opening)
        minimumNumberOfCalls: 15
        # Half-open state: Allow 5 test calls to verify service recovery
        permittedNumberOfCallsInHalfOpenState: 5
        automaticTransitionFromOpenToHalfOpenEnabled: true
        # Wait 2 minutes before trying half-open (gives Plaid time to recover from rate limits/outages)
        waitDurationInOpenState: 2m
        # Failure rate: Open circuit only if 70% of requests fail (more tolerant of transient errors)
        failureRateThreshold: 70
        eventConsumerBufferSize: 10
        # Record exceptions that should count as failures
        recordExceptions:
          - java.net.ConnectException
          - java.net.SocketTimeoutException
          - java.util.concurrent.TimeoutException
          - org.springframework.web.client.HttpServerErrorException
          - com.budgetbuddy.exception.AppException
  retry:
    instances:
      plaid:
        maxAttempts: 3
        waitDuration: 1s
        enableExponentialBackoff: true
        exponentialBackoffMultiplier: 2
        # For rate limit errors, retry with longer delays
        # Note: Resilience4j retry doesn't support different delays per exception type
        # Rate limit errors will use exponential backoff: 1s, 2s, 4s
        # If rate limit persists, circuit breaker will open after multiple failures

