package com.budgetbuddy.service;

import com.budgetbuddy.exception.AppException;
import com.budgetbuddy.exception.ErrorCode;
import com.budgetbuddy.model.dynamodb.AccountTable;
import com.budgetbuddy.model.dynamodb.TransactionTable;
import com.budgetbuddy.model.dynamodb.UserTable;
import com.budgetbuddy.repository.dynamodb.AccountRepository;
import com.budgetbuddy.repository.dynamodb.TransactionRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.Mockito.lenient;
import static org.mockito.Mockito.atLeastOnce;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Unit Tests for TransactionService
 * 
 */
@ExtendWith(MockitoExtension.class)
@org.mockito.junit.jupiter.MockitoSettings(strictness = org.mockito.quality.Strictness.LENIENT)
class TransactionServiceTest {

    @Mock
    private TransactionRepository transactionRepository;

    @Mock
    private AccountRepository accountRepository;

    @Mock
    private TransactionTypeDeterminer transactionTypeDeterminer;

    @Mock
    private TransactionTypeCategoryService transactionTypeCategoryService;

    @Mock
    private com.budgetbuddy.audit.AuditService auditService;

    @InjectMocks
    private TransactionService transactionService;

    private UserTable testUser;
    private AccountTable testAccount;

    @BeforeEach
    void setUp() {
        testUser = new UserTable();
        testUser.setUserId("user-123");
        testUser.setEmail("test@example.com");
        testUser.setPreferredCurrency("USD");

        testAccount = new AccountTable();
        testAccount.setAccountId("account-123");
        testAccount.setUserId("user-123");
        testAccount.setAccountName("Test Account");
        
        // Default mock for transactionTypeDeterminer (EXPENSE is the default)
        lenient().when(transactionTypeDeterminer.determineTransactionType(any(), anyString(), anyString(), any()))
                .thenReturn(com.budgetbuddy.model.TransactionType.EXPENSE);
    }

    @Test
    void testGetTransactions_WithValidUser_ReturnsTransactions() {
        // Given
        List<TransactionTable> mockTransactions = Arrays.asList(
                createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00)),
                createTransaction("tx-2", "user-123", BigDecimal.valueOf(50.00))
        );
        when(transactionRepository.findByUserId("user-123", 0, 50)).thenReturn(mockTransactions);

        // When
        List<TransactionTable> result = transactionService.getTransactions(testUser, 0, 50);

        // Then
        assertNotNull(result);
        assertEquals(2, result.size());
        verify(transactionRepository).findByUserId("user-123", 0, 50);
    }

    @Test
    void testGetTransactions_WithNullUser_ThrowsException() {
        // When/Then
        AppException exception = assertThrows(AppException.class,
                () -> transactionService.getTransactions(null, 0, 50));
        assertEquals(ErrorCode.INVALID_INPUT, exception.getErrorCode());
    }

    @Test
    void testGetTransactions_WithInvalidPagination_AdjustsLimits() {
        // Given
        when(transactionRepository.findByUserId(anyString(), anyInt(), anyInt()))
                .thenReturn(Collections.emptyList());

        // When - negative skip (should be adjusted to 0)
        transactionService.getTransactions(testUser, -5, 50);
        verify(transactionRepository).findByUserId("user-123", 0, 50);

        // Reset mock
        reset(transactionRepository);
        when(transactionRepository.findByUserId(anyString(), anyInt(), anyInt()))
                .thenReturn(Collections.emptyList());

        // When - limit too high (should be defaulted to 50, not 100)
        transactionService.getTransactions(testUser, 0, 200);
        verify(transactionRepository).findByUserId("user-123", 0, 50);
    }

    @Test
    void testGetTransactionsInRange_WithValidDates_ReturnsTransactions() {
        // Given
        LocalDate startDate = LocalDate.now().minusDays(7);
        LocalDate endDate = LocalDate.now();
        List<TransactionTable> mockTransactions = Arrays.asList(
                createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00))
        );
        when(transactionRepository.findByUserIdAndDateRange(anyString(), anyString(), anyString()))
                .thenReturn(mockTransactions);

        // When
        List<TransactionTable> result = transactionService.getTransactionsInRange(testUser, startDate, endDate);

        // Then
        assertNotNull(result);
        assertEquals(1, result.size());
    }

    @Test
    void testGetTransactionsInRange_WithInvalidDateRange_ThrowsException() {
        // Given
        LocalDate startDate = LocalDate.now();
        LocalDate endDate = LocalDate.now().minusDays(7);

        // When/Then
        AppException exception = assertThrows(AppException.class,
                () -> transactionService.getTransactionsInRange(testUser, startDate, endDate));
        assertEquals(ErrorCode.INVALID_DATE_RANGE, exception.getErrorCode());
    }

    @Test
    void testCreateTransaction_WithValidData_CreatesTransaction() {
        // Given
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));

        // When
        TransactionTable result = transactionService.createTransaction(
                testUser,
                "account-123",
                BigDecimal.valueOf(100.00),
                LocalDate.now(),
                "Test transaction",
                "FOOD"
        );

        // Then
        assertNotNull(result);
        assertNotNull(result.getTransactionId());
        assertEquals("user-123", result.getUserId());
        assertEquals("account-123", result.getAccountId());
        verify(transactionRepository).save(any(TransactionTable.class));
    }

    @Test
    void testCreateTransaction_WithInvalidAccount_ThrowsException() {
        // Given
        when(accountRepository.findById("invalid-account")).thenReturn(Optional.empty());

        // When/Then
        AppException exception = assertThrows(AppException.class,
                () -> transactionService.createTransaction(
                        testUser,
                        "invalid-account",
                        BigDecimal.valueOf(100.00),
                        LocalDate.now(),
                        "Test",
                        "FOOD"
                ));
        assertEquals(ErrorCode.ACCOUNT_NOT_FOUND, exception.getErrorCode());
    }

    @Test
    void testCreateTransaction_WithUnauthorizedAccount_ThrowsException() {
        // Given
        AccountTable otherUserAccount = new AccountTable();
        otherUserAccount.setAccountId("account-456");
        otherUserAccount.setUserId("other-user");
        when(accountRepository.findById("account-456")).thenReturn(Optional.of(otherUserAccount));

        // When/Then
        AppException exception = assertThrows(AppException.class,
                () -> transactionService.createTransaction(
                        testUser,
                        "account-456",
                        BigDecimal.valueOf(100.00),
                        LocalDate.now(),
                        "Test",
                        "FOOD"
                ));
        assertEquals(ErrorCode.UNAUTHORIZED_ACCESS, exception.getErrorCode());
    }

    @Test
    void testCreateTransaction_WithNullAccountId_UsesPseudoAccount() {
        // Given - No accountId provided, should use pseudo account
        AccountTable pseudoAccount = createPseudoAccount(testUser.getUserId());
        when(accountRepository.getOrCreatePseudoAccount(testUser.getUserId())).thenReturn(pseudoAccount);
        doNothing().when(transactionRepository).save(any(TransactionTable.class));

        // When
        TransactionTable result = transactionService.createTransaction(
                testUser,
                null, // No accountId
                BigDecimal.valueOf(100.00),
                LocalDate.now(),
                "Manual transaction",
                "FOOD",
                "RESTAURANTS",
                null, // importerCategoryPrimary
                null, // importerCategoryDetailed
                null, // transactionId
                null, // notes
                null, // plaidAccountId
                null, // plaidTransactionId
                null, // transactionType
                null, // currencyCode
                null, // importSource
                null, // importBatchId
                null, // importFileName,
                null, // reviewStatus
                null, // merchantName
                null, // paymentChannel
                null, // userName
                null  // goalId
        );

        // Then
        assertNotNull(result);
        assertEquals(pseudoAccount.getAccountId(), result.getAccountId());
        verify(accountRepository).getOrCreatePseudoAccount(testUser.getUserId());
        verify(accountRepository, never()).findById(anyString());
    }

    @Test
    void testCreateTransaction_WithEmptyAccountId_UsesPseudoAccount() {
        // Given - Empty accountId provided, should use pseudo account
        AccountTable pseudoAccount = createPseudoAccount(testUser.getUserId());
        when(accountRepository.getOrCreatePseudoAccount(testUser.getUserId())).thenReturn(pseudoAccount);
        doNothing().when(transactionRepository).save(any(TransactionTable.class));

        // When
        TransactionTable result = transactionService.createTransaction(
                testUser,
                "", // Empty accountId
                BigDecimal.valueOf(100.00),
                LocalDate.now(),
                "Manual transaction",
                "FOOD",
                "RESTAURANTS",
                null, // importerCategoryPrimary
                null, // importerCategoryDetailed
                null, // transactionId
                null, // notes
                null, // plaidAccountId
                null, // plaidTransactionId
                null, // transactionType
                null, // currencyCode
                null, // importSource
                null, // importBatchId
                null, // importFileName,
                null, // reviewStatus
                null, // merchantName
                null, // paymentChannel
                null, // userName
                null  // goalId
        );

        // Then
        assertNotNull(result);
        assertEquals(pseudoAccount.getAccountId(), result.getAccountId());
        verify(accountRepository).getOrCreatePseudoAccount(testUser.getUserId());
    }

    @Test
    void testCreateTransaction_WithPlaidAccountId_NeverUsesPseudoAccount() {
        // Given - Plaid transaction with plaidAccountId but no accountId
        // Should find account by Plaid ID, NOT use pseudo account
        AccountTable plaidAccount = new AccountTable();
        plaidAccount.setAccountId("plaid-account-123");
        plaidAccount.setUserId(testUser.getUserId());
        plaidAccount.setPlaidAccountId("plaid-acc-123");
        
        when(accountRepository.findById(null)).thenReturn(Optional.empty());
        when(accountRepository.findByPlaidAccountId("plaid-acc-123")).thenReturn(Optional.of(plaidAccount));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));

        // When - Plaid transaction without accountId
        TransactionTable result = transactionService.createTransaction(
                testUser,
                null, // No accountId
                BigDecimal.valueOf(100.00),
                LocalDate.now(),
                "Plaid transaction",
                "FOOD",
                "RESTAURANTS",
                null, // importerCategoryPrimary
                null, // importerCategoryDetailed
                null, // transactionId
                null, // notes
                "plaid-acc-123", // Plaid account ID
                "plaid-tx-123",   // Plaid transaction ID
                null, // transactionType
                null, // currencyCode
                null, // importSource
                null, // importBatchId
                null, // importFileName,
                null, // reviewStatus
                null, // merchantName
                null, // paymentChannel
                null, // userName
                null  // goalId
        );

        // Then - Should use Plaid account, NOT pseudo account
        assertNotNull(result);
        assertEquals(plaidAccount.getAccountId(), result.getAccountId());
        verify(accountRepository).findByPlaidAccountId("plaid-acc-123");
        verify(accountRepository, never()).getOrCreatePseudoAccount(anyString());
    }

    @Test
    void testCreateTransaction_WithPlaidAccountIdAndAccountId_UsesAccountId() {
        // Given - Plaid transaction with both accountId and plaidAccountId
        AccountTable account = new AccountTable();
        account.setAccountId("account-123");
        account.setUserId(testUser.getUserId());
        account.setPlaidAccountId("plaid-acc-123");
        
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(account));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));

        // When
        TransactionTable result = transactionService.createTransaction(
                testUser,
                "account-123", // Account ID provided
                BigDecimal.valueOf(100.00),
                LocalDate.now(),
                "Plaid transaction",
                "FOOD",
                "RESTAURANTS",
                null, // importerCategoryPrimary
                null, // importerCategoryDetailed
                null, // transactionId
                null, // notes
                "plaid-acc-123", // Plaid account ID
                "plaid-tx-123", // plaidTransactionId
                null, // transactionType
                null, // currencyCode
                null, // importSource
                null, // importBatchId
                null, // importFileName,
                null, // reviewStatus
                null, // merchantName
                null, // paymentChannel
                null, // userName
                null  // goalId
        );

        // Then - Should use provided accountId
        assertNotNull(result);
        assertEquals("account-123", result.getAccountId());
        verify(accountRepository).findById("account-123");
        verify(accountRepository, never()).getOrCreatePseudoAccount(anyString());
    }

    @Test
    void testCreateTransaction_WithPlaidAccountIdButAccountNotFound_ThrowsException() {
        // Given - Plaid transaction but account not found
        when(accountRepository.findById(null)).thenReturn(Optional.empty());
        when(accountRepository.findByPlaidAccountId("plaid-acc-123")).thenReturn(Optional.empty());

        // When/Then - Should throw exception, NOT use pseudo account
        AppException exception = assertThrows(AppException.class,
                () -> transactionService.createTransaction(
                        testUser,
                        null,
                        BigDecimal.valueOf(100.00),
                        LocalDate.now(),
                        "Plaid transaction",
                        "FOOD",
                        "RESTAURANTS",
                        null, // importerCategoryPrimary
                        null, // importerCategoryDetailed
                        null, // transactionId
                        null, // notes
                        "plaid-acc-123", // plaidAccountId
                        "plaid-tx-123", // plaidTransactionId
                        null, // transactionType
                        null, // currencyCode
                        null, // importSource
                        null, // importBatchId
                        null, // importFileName,
                        null, // reviewStatus
                        null, // merchantName
                        null, // paymentChannel
                        null, // userName
                        null  // goalId
                ));
        assertEquals(ErrorCode.ACCOUNT_NOT_FOUND, exception.getErrorCode());
        verify(accountRepository, never()).getOrCreatePseudoAccount(anyString());
    }

    @Test
    void testCreateTransaction_WithAccountId_UsesProvidedAccount() {
        // Given - Manual transaction with accountId
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));

        // When
        TransactionTable result = transactionService.createTransaction(
                testUser,
                "account-123", // Account ID provided
                BigDecimal.valueOf(100.00),
                LocalDate.now(),
                "Manual transaction",
                "FOOD",
                "RESTAURANTS",
                null, // importerCategoryPrimary
                null, // importerCategoryDetailed
                null, // transactionId
                null, // notes
                null, // plaidAccountId
                null, // plaidTransactionId
                null, // transactionType
                null, // currencyCode
                null, // importSource
                null, // importBatchId
                null, // importFileName,
                null, // reviewStatus
                null, // merchantName
                null, // paymentChannel
                null, // userName
                null  // goalId
        );

        // Then - Should use provided account, NOT pseudo account
        assertNotNull(result);
        assertEquals("account-123", result.getAccountId());
        verify(accountRepository).findById("account-123");
        verify(accountRepository, never()).getOrCreatePseudoAccount(anyString());
    }

    // Helper method
    private AccountTable createPseudoAccount(String userId) {
        AccountTable account = new AccountTable();
        account.setAccountId("pseudo-account-" + userId);
        account.setUserId(userId);
        account.setAccountName("Manual Transactions");
        account.setInstitutionName("BudgetBuddy");
        account.setAccountType("other");
        account.setAccountSubtype("manual");
        account.setBalance(BigDecimal.ZERO);
        account.setActive(true);
        return account;
    }

    @Test
    void testDeleteTransaction_WithValidTransaction_DeletesTransaction() {
        // Given
        TransactionTable transaction = createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00));
        when(transactionRepository.findById("tx-1")).thenReturn(Optional.of(transaction));
        doNothing().when(transactionRepository).delete("tx-1");

        // When
        transactionService.deleteTransaction(testUser, "tx-1");

        // Then
        verify(transactionRepository).delete("tx-1");
    }

    @Test
    void testDeleteTransaction_WithUnauthorizedTransaction_ThrowsException() {
        // Given
        TransactionTable otherUserTransaction = createTransaction("tx-1", "other-user", BigDecimal.valueOf(100.00));
        when(transactionRepository.findById("tx-1")).thenReturn(Optional.of(otherUserTransaction));

        // When/Then
        AppException exception = assertThrows(AppException.class,
                () -> transactionService.deleteTransaction(testUser, "tx-1"));
        assertEquals(ErrorCode.UNAUTHORIZED_ACCESS, exception.getErrorCode());
    }

    @Test
    void testGetTotalSpending_WithValidRange_ReturnsTotal() {
        // Given
        LocalDate startDate = LocalDate.now().minusDays(7);
        LocalDate endDate = LocalDate.now();
        List<TransactionTable> transactions = Arrays.asList(
                createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00)),
                createTransaction("tx-2", "user-123", BigDecimal.valueOf(50.00))
        );
        when(transactionRepository.findByUserIdAndDateRange(anyString(), anyString(), anyString()))
                .thenReturn(transactions);

        // When
        BigDecimal total = transactionService.getTotalSpending(testUser, startDate, endDate);

        // Then
        assertEquals(BigDecimal.valueOf(150.00), total);
    }

    @Test
    void testGetTotalSpending_WithNullAmounts_HandlesGracefully() {
        // Given
        LocalDate startDate = LocalDate.now().minusDays(7);
        LocalDate endDate = LocalDate.now();
        TransactionTable tx1 = createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00));
        TransactionTable tx2 = createTransaction("tx-2", "user-123", null);
        when(transactionRepository.findByUserIdAndDateRange(anyString(), anyString(), anyString()))
                .thenReturn(Arrays.asList(tx1, tx2));

        // When
        BigDecimal total = transactionService.getTotalSpending(testUser, startDate, endDate);

        // Then
        assertEquals(BigDecimal.valueOf(100.00), total);
    }

    // Helper methods
    private TransactionTable createTransaction(final String id, final String userId, final BigDecimal amount) {
        TransactionTable transaction = new TransactionTable();
        transaction.setTransactionId(id);
        transaction.setUserId(userId);
        transaction.setAmount(amount);
        transaction.setTransactionDate(LocalDate.now().format(java.time.format.DateTimeFormatter.ISO_LOCAL_DATE));
        transaction.setCategoryPrimary("dining");
        transaction.setCategoryDetailed("dining");
        transaction.setTransactionType("EXPENSE"); // Default transaction type
        return transaction;
    }

    // ========== TRANSACTION TYPE INTEGRATION TESTS ==========

    @Test
    void testCreateTransaction_WithUserProvidedTransactionType_RespectsUserSelection() {
        // Given: User provides transactionType=INVESTMENT
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        when(transactionRepository.findById(anyString())).thenReturn(Optional.empty());
        doNothing().when(transactionRepository).save(any(TransactionTable.class));
        when(transactionTypeDeterminer.determineTransactionType(any(), anyString(), anyString(), any()))
                .thenReturn(com.budgetbuddy.model.TransactionType.EXPENSE); // Would calculate EXPENSE, but user wants INVESTMENT

        // When: Create transaction with user-provided transactionType
        TransactionTable result = transactionService.createTransaction(
                testUser,
                "account-123",
                BigDecimal.valueOf(100.00),
                LocalDate.now(),
                "Test transaction",
                "FOOD",
                "dining",
                null, // importerCategoryPrimary
                null, // importerCategoryDetailed
                null, // transactionId
                null, // notes
                null, // plaidAccountId
                null, // plaidTransactionId
                "INVESTMENT", // User-provided transactionType
                null, // currencyCode
                null, // importSource
                null, // importBatchId
                null, // importFileName,
                null, // reviewStatus
                null, // merchantName
                null, // paymentChannel
                null, // userName
                null  // goalId
        );

        // Then: Should use user-provided type, not calculated type
        assertNotNull(result);
        assertEquals("INVESTMENT", result.getTransactionType());
        verify(transactionRepository).save(any(TransactionTable.class));
    }

    @Test
    void testCreateTransaction_WithExistingTransaction_UpdatesTransactionType() {
        // Given: Transaction already exists with transactionType=EXPENSE
        TransactionTable existing = createTransaction("tx-existing", "user-123", BigDecimal.valueOf(100.00));
        existing.setTransactionType("EXPENSE");
        existing.setPlaidTransactionId("plaid-123");
        
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        when(transactionRepository.findById("tx-existing")).thenReturn(Optional.of(existing));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));

        // When: User tries to create same transaction with different transactionType=INVESTMENT
        TransactionTable result = transactionService.createTransaction(
                testUser,
                "account-123",
                BigDecimal.valueOf(100.00),
                LocalDate.now(),
                "Test transaction",
                "FOOD",
                "dining",
                "tx-existing", // Same transaction ID
                null, // notes
                null, // plaidAccountId
                "plaid-123", // Same Plaid ID (idempotent case)
                "INVESTMENT", // User wants to change type to INVESTMENT
                null, // currencyCode
                null, // importSource
                null, // importBatchId
                null, // importFileName,
                null, // reviewStatus
                null, // merchantName
                null, // paymentChannel
                null, // userName
                null  // goalId
        );

        // Then: Should update existing transaction's transactionType
        assertEquals("INVESTMENT", result.getTransactionType());
        verify(transactionRepository).save(any(TransactionTable.class)); // Should save the updated transaction
    }

    @Test
    void testCreateTransaction_WithExistingTransactionNoPlaidId_UpdatesTransactionType() {
        // Given: Transaction exists without Plaid ID, user provides Plaid ID and transactionType
        TransactionTable existing = createTransaction("tx-existing", "user-123", BigDecimal.valueOf(100.00));
        existing.setTransactionType("EXPENSE");
        existing.setPlaidTransactionId(null); // No Plaid ID yet
        
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        when(transactionRepository.findById("tx-existing")).thenReturn(Optional.of(existing));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));

        // When: User links transaction to Plaid and changes transactionType
        TransactionTable result = transactionService.createTransaction(
                testUser,
                "account-123",
                BigDecimal.valueOf(100.00),
                LocalDate.now(),
                "Test transaction",
                "FOOD",
                "dining",
                null, // importerCategoryPrimary
                null, // importerCategoryDetailed
                "tx-existing", // transactionId
                null, // notes
                null, // plaidAccountId
                "plaid-new-123", // New Plaid ID
                "INVESTMENT", // User-provided transactionType
                null, // currencyCode
                null, // importSource
                null, // importBatchId
                null, // importFileName,
                null, // reviewStatus
                null, // merchantName
                null, // paymentChannel
                null, // userName
                null  // goalId
        );

        // Then: Should update both Plaid ID and transactionType
        assertEquals("plaid-new-123", result.getPlaidTransactionId());
        assertEquals("INVESTMENT", result.getTransactionType());
        verify(transactionRepository).save(any(TransactionTable.class));
    }

    @Test
    void testCreateTransaction_WithInvalidTransactionType_CalculatesAutomatically() {
        // Given: User provides invalid transactionType
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        when(transactionRepository.findById(anyString())).thenReturn(Optional.empty());
        doNothing().when(transactionRepository).save(any(TransactionTable.class));
        when(transactionTypeDeterminer.determineTransactionType(any(), anyString(), anyString(), any()))
                .thenReturn(com.budgetbuddy.model.TransactionType.EXPENSE);

        // When: Create transaction with invalid transactionType
        TransactionTable result = transactionService.createTransaction(
                testUser,
                "account-123",
                BigDecimal.valueOf(100.00),
                LocalDate.now(),
                "Test transaction",
                "FOOD",
                "dining",
                null, // importerCategoryPrimary
                null, // importerCategoryDetailed
                null, // transactionId
                null, // notes
                null, // plaidAccountId
                null, // plaidTransactionId
                "INVALID_TYPE", // Invalid transactionType
                null, // currencyCode
                null, // importSource
                null, // importBatchId
                null, // importFileName,
                null, // reviewStatus
                null, // merchantName
                null, // paymentChannel
                null, // userName
                null  // goalId
        );

        // Then: Should calculate automatically (EXPENSE)
        assertNotNull(result);
        assertEquals("EXPENSE", result.getTransactionType());
        verify(transactionTypeDeterminer).determineTransactionType(any(), anyString(), anyString(), any());
    }

    @Test
    void testSaveTransaction_WithNullTransactionType_CalculatesAutomatically() {
        // Given: Transaction with null transactionType (old transaction)
        TransactionTable transaction = createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00));
        transaction.setTransactionType(null); // Null transactionType
        transaction.setAccountId("account-123");
        
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        when(transactionRepository.saveIfPlaidTransactionNotExists(transaction)).thenReturn(true);
        when(transactionTypeDeterminer.determineTransactionType(any(), anyString(), anyString(), any()))
                .thenReturn(com.budgetbuddy.model.TransactionType.EXPENSE);

        // When: Save transaction with null transactionType
        TransactionTable result = transactionService.saveTransaction(transaction);

        // Then: Should calculate and set transactionType
        assertNotNull(result);
        assertEquals("EXPENSE", result.getTransactionType());
        verify(transactionTypeDeterminer).determineTransactionType(any(), anyString(), anyString(), any());
    }

    @Test
    void testSaveTransaction_WithExistingTransactionNullTransactionType_CalculatesAndSaves() {
        // Given: Existing transaction with null transactionType
        TransactionTable newTransaction = createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00));
        newTransaction.setTransactionType(null);
        newTransaction.setPlaidTransactionId("plaid-123");
        newTransaction.setAccountId("account-123");
        
        TransactionTable existing = createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00));
        existing.setTransactionType(null); // Null transactionType
        existing.setPlaidTransactionId("plaid-123");
        existing.setAccountId("account-123");
        
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        when(transactionRepository.saveIfPlaidTransactionNotExists(newTransaction)).thenReturn(false);
        when(transactionRepository.findByPlaidTransactionId("plaid-123")).thenReturn(Optional.of(existing));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));
        when(transactionTypeDeterminer.determineTransactionType(any(), anyString(), anyString(), any()))
                .thenReturn(com.budgetbuddy.model.TransactionType.EXPENSE);

        // When: Save transaction that already exists with null transactionType
        TransactionTable result = transactionService.saveTransaction(newTransaction);

        // Then: Should calculate and save transactionType for existing transaction
        assertEquals("EXPENSE", result.getTransactionType());
        verify(transactionRepository).save(any(TransactionTable.class)); // Should save the updated existing transaction
        // Note: determineTransactionType may be called multiple times (once for newTransaction, once for existing)
        verify(transactionTypeDeterminer, atLeastOnce()).determineTransactionType(any(), anyString(), anyString(), any());
    }

    @Test
    void testUpdateTransaction_WithUserProvidedTransactionType_RespectsUserSelection() {
        // Given: Existing transaction
        TransactionTable existing = createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00));
        existing.setTransactionType("EXPENSE");
        existing.setAccountId("account-123");
        
        when(transactionRepository.findById("tx-1")).thenReturn(Optional.of(existing));
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));

        // When: Update transaction with user-provided transactionType
        TransactionTable result = transactionService.updateTransaction(
                testUser,
                "tx-1",
                null, // plaidTransactionId
                null, // amount
                null, // notes
                null, // categoryPrimary
                null, // categoryDetailed
                null, // reviewStatus
                null, // isHidden
                "INVESTMENT", // User-provided transactionType
                false, // clearNotesIfNull,
                null  // goalId
        );

        // Then: Should use user-provided transactionType
        assertEquals("INVESTMENT", result.getTransactionType());
        verify(transactionRepository).save(existing);
    }

    @Test
    void testUpdateTransaction_WithCategoryChangeAndNoTransactionType_RecalculatesTransactionType() {
        // Given: Existing transaction with EXPENSE type
        TransactionTable existing = createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00));
        existing.setTransactionType("EXPENSE");
        existing.setCategoryPrimary("dining");
        existing.setCategoryDetailed("dining");
        existing.setAccountId("account-123");
        
        when(transactionRepository.findById("tx-1")).thenReturn(Optional.of(existing));
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));
        when(transactionTypeDeterminer.determineTransactionType(any(), anyString(), anyString(), any()))
                .thenReturn(com.budgetbuddy.model.TransactionType.INCOME); // Category change might change type

        // When: Update category but don't provide transactionType
        TransactionTable result = transactionService.updateTransaction(
                testUser,
                "tx-1",
                null,
                null,
                null,
                "income", // Changed category
                "salary", // Changed detailed category
                null,
                null,
                null, // No user-provided transactionType
                false,
                null  // goalId
        );

        // Then: Should recalculate transactionType based on new category
        assertEquals("INCOME", result.getTransactionType());
        verify(transactionTypeDeterminer).determineTransactionType(any(), eq("income"), eq("salary"), any());
    }

    @Test
    void testUpdateTransaction_WithUserProvidedTransactionTypeAndCategoryChange_UsesUserType() {
        // Given: Existing transaction
        TransactionTable existing = createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00));
        existing.setTransactionType("EXPENSE");
        existing.setAccountId("account-123");
        
        when(transactionRepository.findById("tx-1")).thenReturn(Optional.of(existing));
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));
        when(transactionTypeDeterminer.determineTransactionType(any(), anyString(), anyString(), any()))
                .thenReturn(com.budgetbuddy.model.TransactionType.INCOME); // Would calculate INCOME

        // When: Update category AND provide transactionType
        TransactionTable result = transactionService.updateTransaction(
                testUser,
                "tx-1",
                null,
                null,
                null,
                "income", // Changed category
                "salary",
                null,
                null,
                "INVESTMENT", // User-provided transactionType (should override calculation)
                false,
                null  // goalId
        );

        // Then: Should use user-provided transactionType, not calculated
        assertEquals("INVESTMENT", result.getTransactionType());
        verify(transactionRepository).save(existing);
        // Should NOT call determiner because user provided type
        verify(transactionTypeDeterminer, never()).determineTransactionType(any(), anyString(), anyString(), any());
    }

    // ========== TRANSACTION TYPE OVERRIDDEN FLAG TESTS ==========

    @Test
    void testCreateTransaction_WithUserProvidedTransactionType_SetsOverriddenFlag() {
        // Given: User provides transactionType
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        when(transactionRepository.findById(anyString())).thenReturn(Optional.empty());
        doNothing().when(transactionRepository).save(any(TransactionTable.class));
        when(transactionTypeDeterminer.determineTransactionType(any(), anyString(), anyString(), any()))
                .thenReturn(com.budgetbuddy.model.TransactionType.EXPENSE);

        // When: Create transaction with user-provided transactionType
        TransactionTable result = transactionService.createTransaction(
                testUser,
                "account-123",
                BigDecimal.valueOf(100.00),
                LocalDate.now(),
                "Test transaction",
                "FOOD",
                "dining",
                null, // importerCategoryPrimary
                null, // importerCategoryDetailed
                null, // transactionId
                null, // notes
                null, // plaidAccountId
                null, // plaidTransactionId
                "INVESTMENT", // User-provided
                null, // currencyCode
                null, // importSource
                null, // importBatchId
                null, // importFileName,
                null, // reviewStatus
                null, // merchantName
                null, // paymentChannel
                null, // userName
                null  // goalId
        );

        // Then: Should set transactionTypeOverridden=true
        assertNotNull(result);
        assertEquals("INVESTMENT", result.getTransactionType());
        assertTrue(result.getTransactionTypeOverridden(), "transactionTypeOverridden should be true when user provides type");
    }

    @Test
    void testCreateTransaction_WithoutUserProvidedTransactionType_SetsOverriddenFlagFalse() {
        // Given: No user-provided transactionType
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        when(transactionRepository.findById(anyString())).thenReturn(Optional.empty());
        doNothing().when(transactionRepository).save(any(TransactionTable.class));
        when(transactionTypeDeterminer.determineTransactionType(any(), anyString(), anyString(), any()))
                .thenReturn(com.budgetbuddy.model.TransactionType.EXPENSE);

        // When: Create transaction without user-provided transactionType
        TransactionTable result = transactionService.createTransaction(
                testUser,
                "account-123",
                BigDecimal.valueOf(100.00),
                LocalDate.now(),
                "Test transaction",
                "FOOD",
                "dining",
                null, // importerCategoryPrimary
                null, // importerCategoryDetailed
                null, // transactionId
                null, // notes
                null, // plaidAccountId
                null, // plaidTransactionId
                null, // No user-provided type
                null, // currencyCode
                null, // importSource
                null, // importBatchId
                null, // importFileName,
                null, // reviewStatus
                null, // merchantName
                null, // paymentChannel
                null, // userName
                null  // goalId
        );

        // Then: Should set transactionTypeOverridden=false
        assertNotNull(result);
        assertEquals("EXPENSE", result.getTransactionType());
        assertFalse(result.getTransactionTypeOverridden(), "transactionTypeOverridden should be false when calculated automatically");
    }

    @Test
    void testUpdateTransaction_WithUserProvidedTransactionType_SetsOverriddenFlag() {
        // Given: Existing transaction without override
        TransactionTable existing = createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00));
        existing.setTransactionType("EXPENSE");
        existing.setTransactionTypeOverridden(false);
        existing.setAccountId("account-123");
        
        when(transactionRepository.findById("tx-1")).thenReturn(Optional.of(existing));
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));

        // When: Update with user-provided transactionType
        TransactionTable result = transactionService.updateTransaction(
                testUser,
                "tx-1",
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                "INVESTMENT", // User-provided
                false, // clearNotesIfNull
                null  // goalId
        );

        // Then: Should set transactionTypeOverridden=true
        assertEquals("INVESTMENT", result.getTransactionType());
        assertTrue(result.getTransactionTypeOverridden(), "transactionTypeOverridden should be true when user provides type");
    }

    @Test
    void testUpdateTransaction_WithCategoryChangeButOverridden_PreservesUserType() {
        // Given: Existing transaction with user override
        TransactionTable existing = createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00));
        existing.setTransactionType("INVESTMENT");
        existing.setTransactionTypeOverridden(true); // User has overridden
        existing.setCategoryPrimary("dining");
        existing.setCategoryDetailed("dining");
        existing.setAccountId("account-123");
        
        when(transactionRepository.findById("tx-1")).thenReturn(Optional.of(existing));
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));
        when(transactionTypeDeterminer.determineTransactionType(any(), anyString(), anyString(), any()))
                .thenReturn(com.budgetbuddy.model.TransactionType.EXPENSE); // Would calculate EXPENSE

        // When: Update category but don't provide transactionType
        TransactionTable result = transactionService.updateTransaction(
                testUser,
                "tx-1",
                null,
                null,
                null,
                "income", // Changed category
                "salary",
                null,
                null,
                null, // No user-provided transactionType
                false,
                null  // goalId
        );

        // Then: Should preserve user's INVESTMENT type (not recalculate)
        assertEquals("INVESTMENT", result.getTransactionType());
        assertTrue(result.getTransactionTypeOverridden(), "transactionTypeOverridden should remain true");
        // Should NOT recalculate because it's overridden
        verify(transactionTypeDeterminer, never()).determineTransactionType(any(), anyString(), anyString(), any());
    }

    @Test
    void testSaveTransaction_WithOverriddenTransactionType_PreservesUserType() {
        // Given: Transaction with user override
        TransactionTable transaction = createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00));
        transaction.setTransactionType("INVESTMENT");
        transaction.setTransactionTypeOverridden(true); // User has overridden
        transaction.setAccountId("account-123");
        
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        when(transactionRepository.saveIfPlaidTransactionNotExists(transaction)).thenReturn(true);
        when(transactionTypeDeterminer.determineTransactionType(any(), anyString(), anyString(), any()))
                .thenReturn(com.budgetbuddy.model.TransactionType.EXPENSE); // Would calculate EXPENSE

        // When: Save transaction (Plaid sync)
        TransactionTable result = transactionService.saveTransaction(transaction);

        // Then: Should preserve user's INVESTMENT type
        assertEquals("INVESTMENT", result.getTransactionType());
        assertTrue(result.getTransactionTypeOverridden(), "transactionTypeOverridden should remain true");
        // Should NOT recalculate because it's overridden
        verify(transactionTypeDeterminer, never()).determineTransactionType(any(), anyString(), anyString(), any());
    }

    @Test
    void testSaveTransaction_WithNullTransactionTypeButOverridden_PreservesOverrideFlag() {
        // Given: Transaction with override flag but null type (edge case)
        TransactionTable transaction = createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00));
        transaction.setTransactionType(null);
        transaction.setTransactionTypeOverridden(true); // User wants to override, but type is null
        transaction.setAccountId("account-123");
        
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        when(transactionRepository.saveIfPlaidTransactionNotExists(transaction)).thenReturn(true);
        when(transactionTypeDeterminer.determineTransactionType(any(), anyString(), anyString(), any()))
                .thenReturn(com.budgetbuddy.model.TransactionType.EXPENSE);

        // When: Save transaction
        TransactionTable result = transactionService.saveTransaction(transaction);

        // Then: Should calculate type (null type takes precedence over override flag)
        assertEquals("EXPENSE", result.getTransactionType());
        // Override flag should be preserved (user's intent to override is respected)
        assertTrue(result.getTransactionTypeOverridden(), "transactionTypeOverridden should remain true");
    }

    @Test
    void testCreateTransaction_WithExistingTransactionOverridden_RespectsExistingOverride() {
        // Given: Existing transaction with user override
        TransactionTable existing = createTransaction("tx-existing", "user-123", BigDecimal.valueOf(100.00));
        existing.setTransactionType("INVESTMENT");
        existing.setTransactionTypeOverridden(true); // User has overridden
        existing.setPlaidTransactionId("plaid-123");
        
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        when(transactionRepository.findById("tx-existing")).thenReturn(Optional.of(existing));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));

        // When: Try to create same transaction with different transactionType
        TransactionTable result = transactionService.createTransaction(
                testUser,
                "account-123",
                BigDecimal.valueOf(100.00),
                LocalDate.now(),
                "Test transaction",
                "FOOD",
                "dining",
                null, // importerCategoryPrimary
                null, // importerCategoryDetailed
                "tx-existing", // transactionId
                null, // notes
                null, // plaidAccountId
                "plaid-123", // plaidTransactionId
                "EXPENSE", // User wants to change to EXPENSE
                null, // currencyCode
                null, // importSource
                null, // importBatchId
                null, // importFileName,
                null, // reviewStatus
                null, // merchantName
                null, // paymentChannel
                null, // userName
                null  // goalId
        );

        // Then: Should update to new user-provided type and keep override flag
        assertEquals("EXPENSE", result.getTransactionType());
        assertTrue(result.getTransactionTypeOverridden(), "transactionTypeOverridden should remain true");
        verify(transactionRepository).save(any(TransactionTable.class));
    }

    @Test
    void testUpdateTransaction_WithEmptyStringTransactionType_TreatsAsNull() {
        // Given: User sends empty string for transactionType
        TransactionTable existing = createTransaction("tx-1", "user-123", BigDecimal.valueOf(100.00));
        existing.setTransactionType("EXPENSE");
        existing.setAccountId("account-123");
        
        when(transactionRepository.findById("tx-1")).thenReturn(Optional.of(existing));
        when(accountRepository.findById("account-123")).thenReturn(Optional.of(testAccount));
        doNothing().when(transactionRepository).save(any(TransactionTable.class));
        when(transactionTypeDeterminer.determineTransactionType(any(), anyString(), anyString(), any()))
                .thenReturn(com.budgetbuddy.model.TransactionType.INCOME);

        // When: Update with empty string transactionType
        TransactionTable result = transactionService.updateTransaction(
                testUser,
                "tx-1",
                null,
                null,
                null,
                "income", // Category changed
                "salary",
                null,
                null,
                "   ", // Empty/whitespace string (should be treated as null)
                false,
                null  // goalId
        );

        // Then: Should recalculate (empty string treated as null)
        assertEquals("INCOME", result.getTransactionType());
        verify(transactionTypeDeterminer).determineTransactionType(any(), eq("income"), eq("salary"), any());
    }
}

